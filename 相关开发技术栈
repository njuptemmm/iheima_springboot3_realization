## Docker

### 0.Docker及其相关知识

#### Docker 的核心概念

- **镜像 (Image)**：一个包含应用程序及其所有依赖项（如代码、运行时环境、库、配置文件等）的模板。镜像是一个只读的文件，它定义了容器将如何运行。你可以从公共仓库（如 Docker Hub）下载现有的镜像，也可以用 **Dockerfile** 来自定义创建。
- **容器 (Container)**：一个由镜像创建出来的、可运行的实例。你可以把它看作是应用程序的一个独立、隔离的运行环境。每个容器都运行在自己的沙盒中，互不影响，并且可以被轻松地创建、启动、停止、删除。
- **Dockerfile**：一个文本文件，其中包含了一系列指令，用于自动构建 Docker 镜像。它定义了构建镜像的每一个步骤，比如从哪个基础镜像开始、复制哪些文件、安装哪些软件、以及启动容器时要运行什么命令。
- Docker 的流行是因为它解决了软件开发和部署中的一个常见问题：“在我的机器上能运行，但在服务器上就不行了！”。这通常是由于不同环境之间的配置差异造成的。

#### 使用Docker所需的准备

使用maven进行打包（使用maven内置的命令可以将程序打包成一个JAR文件）

- 在根目录中
- 运行`mvn clean package`
  - 编译你的 Java 源代码。
  - 运行任何单元测试。
  - 将编译好的 `.class` 文件和项目资源文件打包成一个 **JAR 文件**。



### 1. 编写 Dockerfile



Dockerfile 是一个文本文件，包含了构建 Docker 镜像所需的所有指令。以下是一个典型的 Spring Boot 项目的 Dockerfile 示例：

Dockerfile（这里是创建一个Dockerfile，让你保存在你springboot的根目录中，这样后面使用docker进行打包相关操作的时候可以直接运行相关的程序，完成打包）



```bash
# 基础镜像，通常使用 Java 的官方镜像->这里主要就看看你开发时候使用的java版本是什么样的
FROM openjdk:17-jdk-slim

# 暴露 Spring Boot 应用的端口，默认为 8080
EXPOSE 8080

# 在容器中创建 /app 目录
WORKDIR /app

# 将本地的 Spring Boot jar 包复制到容器的 /app 目录并重命名为 app.jar
# 'target/your-app-name.jar' 是您本地项目打包后的路径->注意前面的这个是一个路径，于是中间不能用空格，同时后面的/app/app.jar是目标路径，指定了文件在 Docker 镜像内部的位置和名称
COPY target/your-app-name.jar /app/app.jar

# 定义容器启动时执行的命令
# java -jar /app/app.jar 会启动您的 Spring Boot 应用
#其实也就对应我上一步中将打包完成的/app/app.jar进行复制到下一步，进行容器的执行
ENTRYPOINT ["java", "-jar", "/app/app.jar"]
```

在编写 Dockerfile 时，请确保：

- **`FROM`**：选择一个合适的 **基础镜像**。`openjdk:17-jdk-slim` 是一个轻量级的选择，非常适合生产环境。
- **`EXPOSE`**：指定您的 Spring Boot 应用程序监听的端口。默认情况下，Spring Boot 应用通常在 **8080** 端口运行。也就我们
- **`COPY`**：确保 `target/your-app-name.jar` 的路径是正确的，它指向您打包好的可执行 JAR 文件。
- **`ENTRYPOINT`**：这是容器启动时要执行的命令。`java -jar /app/app.jar` 会运行您的应用程序。

再运行第一步的时候有时会卡在下载openjdk:17-jdk-slim这一步中，具体的表现是在下载的出现超时，提示连接不上相关网站

```bash
docker pull openjdk:17-jdk-slim
```

此时我们可以直接从网站中下载对应的依赖（也就是我上面使用的这个命令）



### 2. 构建 Docker 镜像



我们需要得知的是需要电脑本身需要先启动docker desktop才能够和docker网络进行连接，才能在命令行引用docker相关的库进行处理

在您的 Spring Boot 项目根目录下，使用以下命令来构建 Docker 镜像：

Bash

```
docker build -t your-image-name .
```

- **`docker build`** 是构建镜像的命令。
- **`-t your-image-name`** 为您的镜像指定一个 **名称**（tag）。例如：`my-springboot-app:1.0`。这个名称就是你使用过程中
- **`.`** (点号) 表示 Dockerfile 位于当前目录下。

这个命令会读取您的 Dockerfile，并按照其中的指令来创建一个新的 Docker 镜像。



### 3. 运行 Docker 容器

首先我们先要进行了解是的docker镜像和docker容器之间的关系：

**Docker 镜像**可以比喻为**一个模具或一个类（class）**。它是一个只读的模板，包含了运行一个应用所需的所有文件、代码、运行时环境、库文件和依赖项。镜像本身是静态的、不可变的。

**Docker 容器**可以比喻为**用这个模具生产出来的产品，或者由这个类创建出来的实例（instance）**。容器是镜像的一个运行实例，它是一个可读写的运行环境。你可以启动、停止、删除或重启一个容器。

**核心关系总结：**

- **镜像是容器的模板**：容器是基于镜像创建和运行的。
- **镜像本身不可变，容器可变**：镜像是一个只读层，容器则在镜像的基础上添加了一个可写层，所有的修改都发生在这个可写层上。
- **多容器可共享同一镜像**：你可以从同一个镜像创建和运行多个独立的容器。每个容器都拥有自己的文件系统、进程空间和网络接口，彼此之间相互隔离。

**意义**

- 镜像中打包了环境，于是在不同电脑中不用进行额外配置即可完成相关的操作
- 不同的容器共享同一个镜像，每一个容器都是互相独立的
- 打包成镜像之后，之后可以使用`docker pull`直接下载并且运行对应的应用，不用关心使用的变成语言和编程框架



镜像构建完成后，您就可以从这个镜像启动一个容器了。使用以下命令：

Bash

```
docker run -d -p 8080:8080 --name my-springboot-container your-image-name
```

- **`docker run`** 用于启动一个新容器。
- **`-d`** 让容器在 **后台** 运行（"detached" mode）。
- **`-p 8080:8080`** 是 **端口映射**。它将主机的 **8080** 端口映射到容器的 **8080** 端口。这样您就可以通过 `http://localhost:8080` 访问您的应用程序。
- **`--name my-springboot-container`** 为容器指定一个易于识别的 **名称**。
- **`your-image-name`** 是您在第二步中构建的镜像名称。

**docker管理命令**：`docker images`（查看本地所有镜像），`docker ps`（查看正在运行的容器），`docker stop/start/rm`（停止/启动/删除容器），`docker rmi`（删除镜像）。



### 4. 验证



现在，您的 Spring Boot 应用程序应该已经在 Docker 容器中运行了。您可以通过以下方法进行验证：

- **浏览器访问**：打开浏览器并访问 `http://localhost:8080`，查看您的应用程序是否正常响应。

- **查看容器日志**：使用 `docker logs` 命令查看容器的输出日志，检查是否有异常：

  

  ```
  docker logs my-springboot-container
  ```

- **查看运行中的容器**：使用 `docker ps` 命令，您应该能看到您的 Spring Boot 容器正在运行。

通过以上步骤，您就可以成功地为 Spring Boot 项目创建 Docker 镜像并运行容器，实现环境的容器化部署。



## Dify

- 对于DIfy本身，这是一个封装了大模型API交互、管理知识库、设计应用界面的AI应用生产工厂。
- 我们在已经完成Springboot中程序设计的前提之下继续使用Dify，那么Dify能够将你实现的相关功能封装成一个工具，这样大模型就可以在需要的时候进行调用

### 安装相关配置的工作

- 克隆官方的项目`git clone https://github.com/langgenius/dify.git`
- 配置环境变量
  - 在Springboot内部的配置
    - 主要就是使用application.yml这个文件进行配置，之后再开发的代码中会反复用到相关的值
  - 在Dify中配置环境变量（在部署阶段的时候进行配置）
    - 

